package upcloud

import (
	"context"
	"fmt"
	"time"

	"github.com/UpCloudLtd/upcloud-go-api/upcloud"
	"github.com/UpCloudLtd/upcloud-go-api/v4/upcloud/client"
	"github.com/UpCloudLtd/upcloud-go-api/v4/upcloud/request"
	"github.com/UpCloudLtd/upcloud-go-api/v4/upcloud/service"
	"github.com/hashicorp/vault/sdk/framework"
	"github.com/hashicorp/vault/sdk/logical"
)

type upcloudSubaccount struct {
	Username string `json:"username"`
	Password string `json:"password"`
	AllowAPI int    `json:"allow_api"`
	Phone    string `json:"phone"`
	Email    string `json:"email"`
}

func subaccountPaths(b *backend) []*framework.Path {
	return []*framework.Path{
		{
			Pattern: "subaccount/" + framework.GenericNameRegex("subaccount"),

			Fields: map[string]*framework.FieldSchema{},

			Operations: map[logical.Operation]framework.OperationHandler{
				// logical.ReadOperation: &framework.PathOperation{
				// 	Callback: handleSubaccountRead,
				// 	Summary:  "Retrieve the UpCloud subaccount credentials.",
				// },
				logical.UpdateOperation: &framework.PathOperation{
					Callback: b.handleSubaccountWrite,
					Summary:  "Create an UpCloud subaccount spec.",
				},
				logical.CreateOperation: &framework.PathOperation{
					Callback: b.handleSubaccountWrite,
					Summary:  "Create an UpCloud subaccount spec.",
				},
				// logical.DeleteOperation: &framework.PathOperation{
				// 	Callback: handleConfigDelete,
				// 	Summary:  "Deletes the secret at the specified location.",
				// },
				// logical.RevokeOperation: &framework.PathOperation{
				// 	Callback: ,
				// }
			},
			//ExistenceCheck: b.handleExistenceCheck,
		},
		{
			Pattern: "subaccount/" + framework.GenericNameRegex("subaccount") + "/token",
			Fields:  map[string]*framework.FieldSchema{},
			Operations: map[logical.Operation]framework.OperationHandler{
				logical.ReadOperation: &framework.PathOperation{
					Callback: b.handleSubaccountTokenRead,
					Summary:  "Retrieve the UpCloud subaccount credentials.",
				},
				logical.DeleteOperation: &framework.PathOperation{
					Callback: func(c context.Context, r *logical.Request, data *framework.FieldData) (*logical.Response, error) {
						return logical.ErrorResponse("DELETE: HOLY FFF IN CRAP: %#v", data.Raw), fmt.Errorf("DELETE: HOLY YIKES, REVOKE CALLED!!!\n\n\n\nDATA: %v", data.Raw)
					},
				},
				logical.RevokeOperation: &framework.PathOperation{
					Callback: func(c context.Context, r *logical.Request, data *framework.FieldData) (*logical.Response, error) {
						return logical.ErrorResponse("HOLY FFF IN CRAP: %#v", data.Raw), fmt.Errorf("HOLY YIKES, REVOKE CALLED!!!\n\n\n\nDATA: %v", data.Raw)
					},
				},
			},
			//ExistenceCheck: b.handleExistenceCheck,
		},
	}
}

func (b *backend) handleSubaccountWrite(ctx context.Context, req *logical.Request, data *framework.FieldData) (*logical.Response, error) {

	raw, ok := data.Raw["subaccount"]
	if !ok {
		return nil, fmt.Errorf("could not get subaccount")
	}
	sa := raw.(string)
	var subaccount upcloudSubaccount

	subaccount.Username = sa

	entry, err := logical.StorageEntryJSON("subaccount/"+sa, subaccount)
	if err != nil {
		return nil, fmt.Errorf("could not marshal json for upcloud auth: %w", err)
	}

	if err := req.Storage.Put(ctx, entry); err != nil {
		return nil, fmt.Errorf("could not put upcloudConfig to storage: %w", err)
	}

	return nil, nil
}

func (b *backend) handleSubaccountTokenRead(ctx context.Context, req *logical.Request, data *framework.FieldData) (*logical.Response, error) {
	raw, ok := data.Raw["subaccount"]
	if !ok {
		return nil, fmt.Errorf("could not get subaccount")
	}
	sa := raw.(string)

	entry, err := req.Storage.Get(ctx, "subaccount/"+sa)
	if err != nil {
		return nil, fmt.Errorf("reading subacount %s: %w", sa, err)
	}
	if entry == nil {
		return logical.ErrorResponse("subaccount/%s is nil", sa), nil
	}
	var subaccount upcloudSubaccount
	if err := entry.DecodeJSON(&subaccount); err != nil {
		return nil, fmt.Errorf("decoding subaccount: %w", err)
	}

	// TODO: how to generate a password... this is randomly generated by us :)
	password := "asdlkajsdlkajsdlaksjdlASDASDq2123$$"

	configEntry, err := req.Storage.Get(ctx, "config")
	if err != nil {
		return nil, fmt.Errorf("could not get config: %w", err)
	}
	if configEntry == nil {
		return logical.ErrorResponse("backend config not configured"), nil
	}
	var auth upcloudConfig
	if err := configEntry.DecodeJSON(&auth); err != nil {
		return nil, fmt.Errorf("could not decode backend config: %w", err)
	}

	svc := service.New(client.New(auth.Username, auth.Password))
	newAccount, err := svc.CreateSubaccount(&request.CreateSubaccountRequest{
		Subaccount: request.CreateSubaccount{
			Email:    "noreply@verifa.io",
			Phone:    "+358.400000000",
			Username: "hacking4",
			Password: password,
			AllowAPI: 1,
			Language: "en",
			Currency: "EUR",
			Timezone: "UTC",
			// FirstName: "Mr",
			// LastName: "Hack",
			// Company: "verifa",
			// Email: ,
		},
	})
	if err != nil {
		if svcErr, ok := err.(*upcloud.Error); ok {
			return logical.ErrorResponse("received error from UpCloud: error code %s: %s", svcErr.ErrorCode, svcErr.ErrorMessage), nil
		}
		return nil, fmt.Errorf("creating UpCloud subaccount: %w", err)
	}

	resp := b.Secret("mike").Response(map[string]interface{}{
		"username": newAccount.Username,
		"password": password,
	}, map[string]interface{}{
		"beer": "asdjlaskdjlaksjd",
	})
	resp.Secret.TTL = time.Second * 3
	resp.Secret.MaxTTL = time.Second * 3

	return resp, nil
}
